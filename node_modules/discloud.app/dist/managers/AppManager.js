"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v2_1 = require("@discloudapp/api-types/v2");
const util_1 = require("@discloudapp/util");
const App_1 = __importDefault(require("../structures/App"));
const AppBackup_1 = __importDefault(require("../structures/AppBackup"));
const AppUploaded_1 = __importDefault(require("../structures/AppUploaded"));
const CachedManager_1 = __importDefault(require("./CachedManager"));
/**
 * Manager for apps on Discloud
 */
class AppManager extends CachedManager_1.default {
    constructor(discloudApp) {
        super(discloudApp, App_1.default);
    }
    async status(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.appStatus(appID));
        if (Array.isArray(data.apps)) {
            const cache = new Map();
            for (const app of this._addMany(data.apps).values()) {
                cache.set(app.id, app.status);
            }
            return cache;
        }
        return this._add(data.apps).status;
    }
    async terminal(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.appLogs(appID));
        if (Array.isArray(data.apps)) {
            const cache = new Map();
            for (const app of data.apps) {
                cache.set(app.id, app.terminal);
            }
            return cache;
        }
        else {
            return data.apps.terminal;
        }
    }
    async backup(appID = "all") {
        const data = await this.discloudApp.rest.get(v2_1.Routes.appBackup(appID));
        if (Array.isArray(data.backups)) {
            const cache = new Map();
            for (const backup of data.backups) {
                cache.set(backup.id, new AppBackup_1.default(this.discloudApp, backup));
            }
            return cache;
        }
        return new AppBackup_1.default(this.discloudApp, data.backups);
    }
    /**
     * Set the quantity of ram to your application
     *
     * @param appID - Your app id
     * @param quantity - Minimum values is `100` to `bot` or `512` for `site`
     * @returns Promise {@link RESTPutApiAppRamResult}
     */
    async ram(appID, quantity) {
        if (!appID)
            throw new Error("App ID is missing.");
        if (quantity < 100)
            throw new Error("RAM quantity must be more than 100.");
        const data = await this.discloudApp.rest.put(v2_1.Routes.appRam(appID), {
            body: {
                ramMB: quantity,
            },
        });
        if (data.status === "ok")
            this._add({
                id: appID,
                ram: quantity,
            });
        return data;
    }
    /**
     * Upload a new app or site to Discloud
     *
     * @param options - Options for create a new app. A {@link FileResolvable} is required.
     * @returns Promise {@link RESTPostApiUploadResult}
     */
    async create(options) {
        options.file = await (0, util_1.resolveFile)(options.file);
        const data = await this.discloudApp.rest.post(v2_1.Routes.upload(), {
            file: options.file,
        });
        this._add(data.app);
        if ("app" in data)
            return { ...data, app: new AppUploaded_1.default(this.discloudApp, data.app) };
        return data;
    }
    /**
     * Update an of your apps on Discloud.
     *
     * @param appID - Your app id
     * @param options - Options to update your app.
     * @returns Promise {@link RESTPutApiAppCommitResult}
     */
    async update(appID, options) {
        options.file = await (0, util_1.resolveFile)(options.file);
        const data = await this.discloudApp.rest.put(v2_1.Routes.appCommit(appID), {
            file: options.file,
        });
        return data;
    }
    async delete(appID = "all") {
        const data = await this.discloudApp.rest.delete(v2_1.Routes.appDelete(appID));
        if ("apps" in data) {
            this._removeMany(data.apps.removealled);
            return data.apps;
        }
        if (data.status === "ok")
            this._remove(appID);
        return data;
    }
    async restart(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.appRestart(appID));
        if ("apps" in data) {
            this._addMany(data.apps.restarted.map(app => ({
                id: app,
                online: true,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: data.status === "ok",
        });
        return data;
    }
    async start(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.appStart(appID));
        if ("apps" in data) {
            this._addMany(data.apps.started.map(app => ({
                id: app,
                online: true,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: data.status === "ok",
        });
        return data;
    }
    async stop(appID = "all") {
        const data = await this.discloudApp.rest.put(v2_1.Routes.appStop(appID));
        if ("apps" in data) {
            this._addMany(data.apps.stoped.map(app => ({
                id: app,
                online: false,
            })));
            return data.apps;
        }
        this._add({
            id: appID,
            online: !(data.status === "ok"),
        });
        return data;
    }
    async fetch(appID = "all") {
        if (appID === "all")
            return this.#fetchMany();
        const data = await this.discloudApp.rest.get(v2_1.Routes.app(appID));
        return this._add(data.apps);
    }
    async #fetchMany() {
        const data = await this.discloudApp.rest.get(v2_1.Routes.app("all"));
        return this._addMany(data.apps);
    }
}
exports.default = AppManager;
