"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoreFiles = exports.allBlockedFilesRegex = exports.allBlockedFiles = exports.blockedFiles = void 0;
const fs_jetpack_1 = require("fs-jetpack");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
exports.blockedFiles = {
    common: [".git", ".vscode", ".cache"],
    go: [],
    js: ["node_modules", "package-lock.json", "yarn.lock", ".npm"],
    py: ["venv"],
    rb: ["Gemfile.lock"],
    rs: ["Cargo.lock", "target"],
    ts: ["node_modules", "package-lock.json", "yarn.lock", ".npm"],
};
exports.allBlockedFiles = [...new Set(Object.values(exports.blockedFiles).flat())];
exports.allBlockedFilesRegex = RegExp(`(${exports.allBlockedFiles.join("|")})$`.replace(/\./g, "\\."), "i");
class IgnoreFiles {
    fileName;
    filesIgnore = [];
    list = [];
    paths = [];
    constructor(options) {
        if (Array.isArray(options.path)) {
            for (const path of options.path) {
                this.paths.push(this.#normalizePath(path));
            }
        }
        else {
            this.paths.push(this.#normalizePath(options.path));
        }
        this.fileName = options.fileName;
        if (this.fileName && this.paths.length)
            this.filesIgnore = this.#findIgnoreFiles(this.fileName, this.paths);
        options.path = this.paths.flatMap(path => this.#makeBothCase(path));
        this.list = (options.optionalIgnoreList ?? [])
            .flatMap(path => this.#makeBothCase(path))
            .concat(this.#getIgnoreList())
            .concat(this.#resolveIgnorePatterns(exports.allBlockedFiles, options.path));
    }
    #findIgnoreFiles(fileName, paths) {
        return paths.flatMap(path => this.#recursivelyReadDirSync(path)
            .filter(file => file.endsWith(fileName) && (0, fs_jetpack_1.exists)(file) === "file"));
    }
    #makeBothCase(s) {
        if ((0, node_path_1.isAbsolute)(s))
            return [
                s.replace(/^./, a => a.toLowerCase()),
                s.replace(/^./, a => a.toUpperCase()),
            ];
        return [s];
    }
    #getIgnoreList() {
        return this.#resolveIgnoreFile(this.filesIgnore);
    }
    #normalizePath(path) {
        path = path.replace(/\\/g, "/").replace(/[*]/g, "") || ".";
        if (path.length > 1)
            path = path.replace(/\/$/, "");
        return path;
    }
    #resolveIgnorePatterns(ignore, paths) {
        return paths.flatMap(path => {
            path = this.#normalizePath(path);
            return ignore.flatMap(a => [
                a,
                `${(0, node_path_1.isAbsolute)(path) ? a : `**/${a}`}/**`,
                `${path}/**/${a}`,
                `${path}/**/${a}/**`,
            ]);
        });
    }
    #resolveIgnoreFile(ignoreFile) {
        if (Array.isArray(ignoreFile)) {
            const ignored = [];
            for (const file of ignoreFile)
                ignored.push(...this.#resolveIgnoreFile(file));
            return ignored;
        }
        if (typeof ignoreFile === "string" && (0, fs_jetpack_1.exists)(ignoreFile) === "file") {
            const readed = (0, fs_jetpack_1.read)(ignoreFile, "utf8")
                ?.replace(/\s*#.*/g, "")
                .split(/\r?\n/)
                .filter(a => a) ?? [];
            return this.#resolveIgnorePatterns(readed, this.#makeBothCase((0, node_path_1.dirname)(ignoreFile)));
        }
        return [];
    }
    #recursivelyReadDirSync(path) {
        if (!(0, fs_jetpack_1.exists)(path))
            return [];
        if ((0, fs_jetpack_1.exists)(path) === "file")
            return this.#recursivelyReadDirSync((0, node_path_1.dirname)(path));
        const files = (0, node_fs_1.readdirSync)(this.#normalizePath(path), { withFileTypes: true });
        const cache = [];
        for (const file of files) {
            const fileOrDir = (0, node_path_1.join)(path, file.name);
            if (file.isDirectory()) {
                if (exports.allBlockedFilesRegex.test(fileOrDir))
                    continue;
                cache.push(...this.#recursivelyReadDirSync(fileOrDir));
            }
            else {
                cache.push(fileOrDir);
            }
        }
        return cache;
    }
}
exports.IgnoreFiles = IgnoreFiles;
