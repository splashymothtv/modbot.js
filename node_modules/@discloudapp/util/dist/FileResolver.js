"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamToBlob = exports.streamToFile = exports.resolveFile = exports.fileNamePattern = void 0;
const node_fs_1 = require("node:fs");
const node_stream_1 = require("node:stream");
const undici_1 = require("undici");
exports.fileNamePattern = /.*\/+([^?#]+)(?:[?#].*)?/;
/**
 * A function that converts {@link FileResolvable} to {@link File}
 *
 * @param file - The file as {@link FileResolvable} to resolve
 * @param fileName - The name of the file to upload
 */
async function resolveFile(file, fileName) {
    if (file instanceof undici_1.File)
        return file;
    if (file instanceof URL || typeof file === "string") {
        file = file.toString();
        fileName ??= file.match(exports.fileNamePattern)?.pop() ?? "file";
        if (/^https?:\/\//.test(file))
            return (0, undici_1.request)(file, { throwOnError: true })
                .then(res => res.body.blob())
                .then(blob => new undici_1.File([blob], fileName ?? "file"));
        if ((0, node_fs_1.existsSync)(file))
            return streamToFile((0, node_fs_1.createReadStream)(file), fileName);
        return new undici_1.File([file], fileName);
    }
    if (file instanceof Blob)
        return new undici_1.File([file], fileName ?? "file");
    if (Buffer.isBuffer(file))
        return new undici_1.File([file], fileName ?? "file");
    if ("data" in file) {
        if (file.data instanceof undici_1.File)
            return file.data;
        return new undici_1.File([file.data], file.name);
    }
    if (!node_stream_1.Stream.isErrored(file))
        return streamToFile(file);
    throw new TypeError("Invalid file type was provided.");
}
exports.resolveFile = resolveFile;
/**
 * A function that converts a like {@link Stream} parameter to {@link File}
 *
 * @param stream - A parameter like {@link Readable} or {@link Writable}
 * @param fileName - A file name, if you wish
 * @param mimeType - A mimeType parameter
 */
function streamToFile(stream, fileName, mimeType) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on("data", chunk => chunks.push(chunk))
            .once("end", () => resolve(new undici_1.File(chunks, fileName ?? "file", { type: mimeType })))
            .once("error", reject);
    });
}
exports.streamToFile = streamToFile;
/**
 * A function that converts a like {@link Stream} parameter to {@link Blob}
 *
 * @param stream - A parameter like {@link Readable} or {@link Writable}
 * @param mimeType - A mimeType parameter
 */
function streamToBlob(stream, mimeType) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on("data", chunk => chunks.push(chunk))
            .once("end", () => resolve(new Blob(chunks, { type: mimeType })))
            .once("error", reject);
    });
}
exports.streamToBlob = streamToBlob;
exports.default = resolveFile;
