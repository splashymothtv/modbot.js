"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscloudConfig = exports.discloudConfigRequiredScopes = void 0;
const fs_jetpack_1 = require("fs-jetpack");
const node_path_1 = require("node:path");
exports.discloudConfigRequiredScopes = {
    bot: ["MAIN", "NAME", "TYPE", "RAM", "VERSION"],
    site: ["ID", "MAIN", "TYPE", "RAM", "VERSION"],
    common: ["MAIN", "TYPE", "RAM", "VERSION"],
};
class DiscloudConfig {
    path;
    constructor(path) {
        this.path = path;
        try {
            if (this.exists === "file") {
                if (this.path.endsWith("discloud.config"))
                    return;
                this.path = (0, node_path_1.dirname)(this.path);
            }
            this.path = (0, node_path_1.join)(this.path, "discloud.config");
        }
        catch { }
    }
    get comments() {
        try {
            return (0, fs_jetpack_1.read)(this.path, "utf8")
                ?.split(/\r?\n/)
                .filter(a => /^\s*#/.test(a)) ?? [];
        }
        catch {
            return [];
        }
    }
    get data() {
        try {
            return this.#configToObj((0, fs_jetpack_1.read)(this.path, "utf8"));
        }
        catch (error) {
            return {};
        }
    }
    get exists() {
        try {
            return (0, fs_jetpack_1.exists)(this.path);
        }
        catch {
            return false;
        }
    }
    get existsMain() {
        if (this.data.MAIN)
            return (0, fs_jetpack_1.exists)(this.data.MAIN);
    }
    get fileExt() {
        return this.data.MAIN?.split(".").pop();
    }
    get missingProps() {
        return this.#requiredProps
            .filter(key => !this.data[key]);
    }
    get #requiredProps() {
        return exports.discloudConfigRequiredScopes[this.data.TYPE] ??
            exports.discloudConfigRequiredScopes.common;
    }
    #objToString(obj) {
        if (typeof obj === "undefined" || obj === null)
            return "";
        if (typeof obj === "function")
            return this.#configToObj(obj());
        if (!obj)
            return `${obj}`;
        const result = [];
        if (typeof obj === "object") {
            if (Array.isArray(obj)) {
                for (const value of obj)
                    result.push(this.#objToString(value));
            }
            else {
                const keys = Object.keys(obj);
                for (const key of keys)
                    result.push(`${key}=${this.#objToString(obj[key])}`);
            }
        }
        else {
            result.push(obj);
        }
        return result.filter(line => line).join("\n");
    }
    #configToObj(s) {
        if (typeof s !== "string")
            return {};
        return this.#processValues(Object.fromEntries(s
            .replace(/\s*#.*/g, "")
            .split(/[\r\n]/)
            .filter(line => line)
            .map(line => line.split("="))));
    }
    #processValues(obj) {
        if (!obj)
            return obj;
        const keys = Object.keys(obj);
        for (const key of keys) {
            if (["APT", "AVATAR", "ID", "MAIN", "NAME", "TYPE", "VERSION"].includes(key))
                continue;
            const value = obj[key];
            if (!isNaN(Number(value))) {
                obj[key] = Number(value);
                continue;
            }
            if (["true", "false"].includes(obj[key])) {
                obj[key] = value == "true";
                continue;
            }
        }
        return obj;
    }
    get(key) {
        return this.data[key];
    }
    set(key, value) {
        this.update({ [key]: value });
    }
    update(save, comments = this.comments) {
        try {
            save = { ...this.data, ...save };
            (0, fs_jetpack_1.write)(this.path, this.#objToString(comments?.length ?
                [comments, save] :
                save));
        }
        catch (error) {
            return error;
        }
    }
}
exports.DiscloudConfig = DiscloudConfig;
