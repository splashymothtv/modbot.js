"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestManager = void 0;
const node_events_1 = __importDefault(require("node:events"));
const promises_1 = require("node:timers/promises");
const undici_1 = require("undici");
const contants_1 = require("./utils/contants");
class RequestManager extends node_events_1.default {
    #token;
    options;
    /**
     * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
     * performed by this manager.
     */
    agent;
    /**
       * The number of requests remaining in the global bucket
       */
    globalRemaining;
    /**
       * The timestamp at which the global bucket resets
       */
    globalReset = 0;
    constructor(options) {
        super();
        this.options = { ...contants_1.DefaultRestOptions, ...options };
        this.globalRemaining = this.options.globalRequestsPerMinute;
        this.agent = this.options.agent;
    }
    /**
     * If the rate limit bucket is currently limited by its limit
     */
    get globalLimited() {
        return this.globalRemaining < 1 && Date.now() < this.globalReset;
    }
    /**
     * The time until queued requests can continue
     */
    get globalTimeToReset() {
        return this.globalReset - Date.now();
    }
    get token() {
        return this.#token;
    }
    /**
     * Sets the authorization token that should be used for requests
     *
     * @param token - The authorization token to use
     */
    setToken(token) {
        this.#token = token;
        return this;
    }
    resolveRequest(request) {
        const headers = {
            ...this.options.headers,
            "api-token": this.#token,
        };
        const query = request.query?.toString() ? `?${request.query}` : "";
        const url = `${this.options.api}/v${this.options.version}${request.fullRoute}${query}`;
        const additionalHeaders = {};
        const additionalOptions = {};
        const formData = new undici_1.FormData();
        if (request.file) {
            if (request.file instanceof undici_1.File) {
                formData.append("file", request.file);
            }
            else {
                if (request.file.data instanceof undici_1.File) {
                    request.file.name = request.file.name ?? request.file.data.name;
                }
                else {
                    request.file.data = new undici_1.File([request.file.data], request.file.name);
                }
                formData.append(request.file.key ?? "file", request.file.data);
            }
            additionalOptions.headersTimeout = 300000;
        }
        else if (request.body) {
            additionalHeaders["Content-Type"] = "application/json";
        }
        const fetchOptions = {
            headers: { ...(request.headers ?? {}), ...additionalHeaders, ...headers },
            method: request.method.toUpperCase(),
            ...additionalOptions,
        };
        if (request.body)
            if (request.file) {
                for (const [key, value] of Object.entries(request.body))
                    formData.append(key, value);
            }
            else {
                fetchOptions.body = JSON.stringify(request.body);
            }
        if (request.file)
            fetchOptions.body = formData;
        // Prioritize setting an agent per request, use the agent for this instance otherwise.
        fetchOptions.dispatcher = request.dispatcher ?? this.agent;
        return { url, fetchOptions };
    }
    async request(url, options) {
        while (this.globalLimited) {
            this.emit("rateLimited", {
                global: this.globalLimited,
                method: options.method ?? "GET",
                timeToReset: this.globalTimeToReset,
                url,
            });
            await (0, promises_1.setTimeout)(this.globalTimeToReset);
        }
        const res = await (0, undici_1.request)(url, options);
        this.globalRemaining = Number(res.headers["ratelimit-remaining"]);
        this.globalReset = Date.now() + (Number(res.headers["ratelimit-reset"]) * 1000);
        if (res.statusCode > 399 && res.statusCode < 600) {
            const body = await res.body.json();
            throw new Error(`\x1b[31m[DISCLOUD API] ${body.message}\x1b[0m`);
        }
        return res;
    }
}
exports.RequestManager = RequestManager;
